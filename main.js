// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, PACKETS, SrcDS, decHex, decInt, decSigned, decString, dgram,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dgram = require("dgram");

  EventEmitter = require('events').EventEmitter;

  PACKETS = {
    info: new Buffer(["0xff", "0xff", "0xff", "0xff", "0x54", "0x53", "0x6f", "0x75", "0x72", "0x63", "0x65", "0x20", "0x45", "0x6e", "0x67", "0x69", "0x6e", "0x65", "0x20", "0x51", "0x75", "0x65", "0x72", "0x79", "0x00"])
  };

  decString = function(buf, start, end) {
    if (end < start) {
      return "";
    } else if (end > buf.length) {
      return "";
    } else {
      return buf.toString("utf8", start, end);
    }
  };

  decHex = function(buf, pos) {
    return buf.toString("hex", pos, pos + 1);
  };

  decInt = function(buf, pos) {
    if (pos > buf.length) {
      return 0;
    } else {
      return buf.readUInt8(pos);
    }
  };

  decSigned = function(buf, pos) {
    return buf.readInt16LE(pos);
  };

  SrcDS = (function(_super) {

    __extends(SrcDS, _super);

    function SrcDS(ip, port, options) {
      var _base, _ref;
      if (options == null) {
        options = {};
      }
      this.onMsg = __bind(this.onMsg, this);

      if (this === global) {
        return new SrcDS(ip, port, options);
      }
      _ref = [ip, port, options], this.ip = _ref[0], this.port = _ref[1], this.options = _ref[2];
      this.client = dgram.createSocket('udp4');
      this.client.on('message', this.onMsg);
      (_base = this.options).timeout || (_base.timeout = 10000);
    }

    SrcDS.prototype.send = function(packet, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      return this.client.send(packet, 0, packet.length, this.port, this.ip, function(err) {
        var msgcb, timeout;
        if (err) {
          return cb(err);
        } else {
          timeout = null;
          msgcb = function(msg) {
            clearTimeout(timeout);
            return cb(null, msg);
          };
          _this.once('message', msgcb);
          return timeout = setTimeout(function() {
            _this.removeListener('message', msgcb);
            return cb(new Error("Request timed out"));
          }, _this.options.timeout);
        }
      });
    };

    SrcDS.prototype.info = function(cb) {
      return this.send(PACKETS.info, cb);
    };

    SrcDS.prototype.onMsg = function(msg, rinfo) {
      var decoded, i, points;
      decoded = {
        ip: rinfo.address,
        port: rinfo.port
      };
      points = [6];
      i = 0;
      while (i < msg.length) {
        if (msg.readUInt8(i) === 0) {
          points.push(i);
        }
        i++;
      }
      if (points.length < 3) {
        this.emit("error", decoded);
        return;
      }
      i = 0;
      while (i < points.length) {
        switch (i) {
          case 0:
            decoded.serverName = decString(msg, points[i], points[i + 1]);
            break;
          case 1:
            decoded.map = decString(msg, points[i] + 1, points[i + 1]);
            break;
          case 2:
            decoded.gameType = decString(msg, points[i] + 1, points[i + 1]);
            break;
          case 3:
            decoded.gameName = decString(msg, points[i] + 1, points[i + 1]);
            break;
          case 4:
            decoded.appID = decSigned(msg, points[i] + 1);
            decoded.numPlayers = decInt(msg, points[i] + 3);
            decoded.maxPlayers = decInt(msg, points[i] + 4);
            decoded.numBots = decInt(msg, points[i] + 5);
            decoded.dedicated = decString(msg, points[i] + 6, points[i] + 7);
            decoded.os = decString(msg, points[i] + 7, points[i] + 8);
            decoded.pw = decInt(msg, points[i] + 8);
            decoded.secure = decInt(msg, points[i] + 9);
        }
        i++;
      }
      switch (decoded.os) {
        case "l":
          decoded.os = "Linux";
          break;
        case "w":
          decoded.os = "Windows";
      }
      switch (decoded.dedicated) {
        case "d":
          decoded.dedicated = "dedicated";
          break;
        case "l":
          decoded.dedicated = "listen";
          break;
        case "p":
          decoded.dedicated = "SourceTV";
      }
      decoded.pw = decoded.pw === 1;
      decoded.secure = decoded.secure === 1;
      return this.emit("message", decoded);
    };

    SrcDS.prototype.close = function() {
      return this.client.close();
    };

    return SrcDS;

  })(EventEmitter);

  module.exports = SrcDS;

}).call(this);
