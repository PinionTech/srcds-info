// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, PACKETS, RESPONSES, SrcDS, dgram, packet,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dgram = require("dgram");

  packet = require("packet");

  EventEmitter = require('events').EventEmitter;

  PACKETS = {
    info: new Buffer(["0xff", "0xff", "0xff", "0xff", "0x54", "0x53", "0x6f", "0x75", "0x72", "0x63", "0x65", "0x20", "0x45", "0x6e", "0x67", "0x69", "0x6e", "0x65", "0x20", "0x51", "0x75", "0x65", "0x72", "0x79", "0x00"])
  };

  RESPONSES = {
    info: "x32,\nb8|chr() => type,\nb8 => version,\nb8z|utf8() => serverName,\nb8z|utf8() => map,\nb8z|utf8() => gameType,\nb8z|utf8() => gameName,\nl16 => appID,\nb8 => numPlayers,\nb8 => maxPlayers,\nb8 => numBots,\nb8|chr() => dedicated,\nb8|chr() => os,\nb8 => password,\nb8 => secure,\nb8z|utf8() => gameVersion"
  };

  SrcDS = (function(_super) {

    __extends(SrcDS, _super);

    function SrcDS(ip, port, options) {
      var parser, _base, _ref,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.onMsg = __bind(this.onMsg, this);

      if (this === global) {
        return new SrcDS(ip, port, options);
      }
      _ref = [ip, port, options], this.ip = _ref[0], this.port = _ref[1], this.options = _ref[2];
      this.client = dgram.createSocket('udp4');
      parser = new packet.Parser();
      parser._transforms.chr = function(parsing, field, value) {
        if (parsing) {
          return String.fromCharCode(value);
        } else {
          return value.charCodeAt();
        }
      };
      parser.extract(RESPONSES.info, function(msg) {
        return _this.onMsg(msg);
      });
      this.client.on('message', function(msg, rinfo) {
        _this.ip = rinfo.address;
        _this.port = rinfo.port;
        return parser.write(msg);
      });
      (_base = this.options).timeout || (_base.timeout = 10000);
    }

    SrcDS.prototype.send = function(packet, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      return this.client.send(packet, 0, packet.length, this.port, this.ip, function(err) {
        var msgcb, timeout;
        if (err) {
          return cb(err);
        } else {
          timeout = null;
          msgcb = function(msg) {
            clearTimeout(timeout);
            return cb(null, msg);
          };
          _this.once('message', msgcb);
          return timeout = setTimeout(function() {
            _this.removeListener('message', msgcb);
            return cb(new Error("Request timed out"));
          }, _this.options.timeout);
        }
      });
    };

    SrcDS.prototype.info = function(cb) {
      return this.send(PACKETS.info, cb);
    };

    SrcDS.prototype.onMsg = function(msg, rinfo) {
      var decoded;
      decoded = msg;
      decoded.ip = this.ip;
      decoded.port = this.port;
      switch (decoded.os) {
        case "l":
          decoded.os = "Linux";
          break;
        case "w":
          decoded.os = "Windows";
      }
      switch (decoded.dedicated) {
        case "d":
          decoded.dedicated = "dedicated";
          break;
        case "l":
          decoded.dedicated = "listen";
          break;
        case "p":
          decoded.dedicated = "SourceTV";
      }
      decoded.pw = decoded.pw === 1;
      decoded.secure = decoded.secure === 1;
      return this.emit("message", decoded);
    };

    SrcDS.prototype.close = function() {
      return this.client.close();
    };

    return SrcDS;

  })(EventEmitter);

  module.exports = SrcDS;

}).call(this);
